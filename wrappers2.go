/*
This file produces type-specific wrappers for the twiddle algorithm.
Code generated by gen-choose.go.  DO NOT EDIT.
*/

package choose

import "reflect"

// Strings returns all length-M combinations of a slice of strings one at a
// time on a channel.
func Strings(a []string, m int) <-chan []string {
	ch := make(chan []string, 100)
	st := newState(a, m)
	at := reflect.TypeOf(a)
	go func() {
		ch <- st.C.Interface().([]string)
		for st.nextCombination() {
			cv := reflect.MakeSlice(at, m, m)
			reflect.Copy(cv, st.C)
			cv.Index(st.Z).Set(st.A.Index(st.X))
			st.C = cv
			ch <- st.C.Interface().([]string)
		}
		close(ch)
	}()
	return ch
}

// Ints returns all length-M combinations of a slice of ints one at a
// time on a channel.
func Ints(a []int, m int) <-chan []int {
	ch := make(chan []int, 100)
	st := newState(a, m)
	at := reflect.TypeOf(a)
	go func() {
		ch <- st.C.Interface().([]int)
		for st.nextCombination() {
			cv := reflect.MakeSlice(at, m, m)
			reflect.Copy(cv, st.C)
			cv.Index(st.Z).Set(st.A.Index(st.X))
			st.C = cv
			ch <- st.C.Interface().([]int)
		}
		close(ch)
	}()
	return ch
}

// Float64s returns all length-M combinations of a slice of float64s one at a
// time on a channel.
func Float64s(a []float64, m int) <-chan []float64 {
	ch := make(chan []float64, 100)
	st := newState(a, m)
	at := reflect.TypeOf(a)
	go func() {
		ch <- st.C.Interface().([]float64)
		for st.nextCombination() {
			cv := reflect.MakeSlice(at, m, m)
			reflect.Copy(cv, st.C)
			cv.Index(st.Z).Set(st.A.Index(st.X))
			st.C = cv
			ch <- st.C.Interface().([]float64)
		}
		close(ch)
	}()
	return ch
}
