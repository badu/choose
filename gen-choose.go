// +build ignore

/*
gen-choose generates type-dependent wrappers for the choose package's generic
routines.  It is intended to be called by "go generate".
*/
package main

import (
	"fmt"
	"os"
	"strings"
	"text/template"
)

// outName names the file we will generate.
const outName = "wrappers2.go"

// chooseBody is a template for a user-callable, type-specific wrapper for the
// twiddle algorithm.
const chooseBody = `
// {{UpperFirst .}}s returns all length-M combinations of a slice of {{.}}s one at a
// time on a channel.
func {{UpperFirst .}}s(a []{{.}}, m int) <-chan []{{.}} {
	ch := make(chan []{{.}}, 100)
	st := newState(a, m)
	at := reflect.TypeOf(a)
	go func() {
		ch <- st.C.Interface().([]{{.}})
		for st.nextCombination() {
			cv := reflect.MakeSlice(at, m, m)
			reflect.Copy(cv, st.C)
			cv.Index(st.Z).Set(st.A.Index(st.X))
			st.C = cv
			ch <- st.C.Interface().([]{{.}})
		}
		close(ch)
	}()
	return ch
}
`

func main() {
	// Open the output file.
	w, err := os.Create(outName)
	if err != nil {
		panic(err)
	}
	defer w.Close()

	// Output some header boilerplate.
	fmt.Fprint(w, `/*
This file produces type-specific wrappers for the twiddle algorithm.
Code generated by gen-choose.go.  DO NOT EDIT.
*/

package choose

import "reflect"
`)
	fm := template.FuncMap{
		"UpperFirst": func(s string) string {
			return strings.ToUpper(s[:1]) + s[1:]
		},
	}
	tmpl, err := template.New("code").Funcs(fm).Parse(chooseBody)
	if err != nil {
		panic(err)
	}
	for _, t := range os.Args[1:] {
		tmpl.Execute(w, t)
	}
}
