// +build ignore

/*
gen-choose generates type-dependent wrappers for the choose package's generic
routines.  It is intended to be called by "go generate".
*/
package main

import (
	"fmt"
	"os"
	"strings"
	"text/template"
)

// outName names the file we will generate.
const outName = "wrappers2.go"

// chooseBody is a template for a user-callable, type-specific wrapper for the
// twiddle algorithm.
const chooseBody = `
// {{UpperFirst .}}s returns all length-M combinations of a slice of {{.}}s one at a
// time on a channel.
func {{UpperFirst .}}s(a []{{.}}, m int) <-chan []{{.}} {
	// Initialize our state.
	ch := make(chan []{{.}}, 100)
	n := len(a)
	st := newState(n, m)
	c := make([]{{.}}, m)
	for i := range c {
		c[i] = a[n-m+i]
	}

	// Spawn a goroutine to write all combinations into the channel.  We
	// always return a copy of the combination rather than the original
	// because the combination itself is modified in place.
	go func() {
		cCopy := make([]{{.}}, m)
		copy(cCopy, c)
		ch <- cCopy
		for st.nextCombination() {
			c[st.Z] = a[st.X]
			cCopy := make([]{{.}}, m)
			copy(cCopy, c)
			ch <- cCopy
		}
		close(ch)
	}()
	return ch
}
`

func main() {
	// Open the output file.
	w, err := os.Create(outName)
	if err != nil {
		panic(err)
	}
	defer w.Close()

	// Output some header boilerplate.
	fmt.Fprint(w, `/*
This file produces type-specific wrappers for the twiddle algorithm.
Code generated by gen-choose.go.  DO NOT EDIT.
*/

package choose
`)
	fm := template.FuncMap{
		"UpperFirst": func(s string) string {
			return strings.ToUpper(s[:1]) + s[1:]
		},
	}
	tmpl, err := template.New("code").Funcs(fm).Parse(chooseBody)
	if err != nil {
		panic(err)
	}
	for _, t := range os.Args[1:] {
		tmpl.Execute(w, t)
	}
}
